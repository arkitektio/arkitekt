# arkitekt

[![codecov](https://codecov.io/gh/jhnnsrs/arkitekt-client/branch/master/graph/badge.svg?token=UGXEA2THBV)](https://codecov.io/gh/jhnnsrs/arkitekt-client)

self-documenting asynchronous scalable RPC

## Idea

arkitekt is the python client for the arkitekt server, a central repository for the provision and calling of functions in distributed apps.

Together with fluss it provides the backbone of the mikro platform, that enables distributed scalable reactive workflows.



## Install

```bash
pip install arkitekt
```

arkitekt is relying heavily on asyncio patters and therfore supports python 3.7 and above. It also relies on the pydantic stack for serialization.


arkitekt installs also *three sister packages*:

**koil** -  an abstraction layer on top of asyncio to enable usage of async apis (syncronously) in other event loops (qt, juypter)

**fakts** - an configuration discovery agent that helps with locating the backend services (think oauth2 for configuration)

**herre** - an async implentation of oauth2 authenticaiton flows. (authorizaiton code + client credentials)

> If you are working in image analysis checkout the mikro platform that also provides data structures for image analysis.



## Get started

```python
from arkitekt import register

@register()
def rpc_function(x: int, name: str) -> str
    """ 
    A rpc function that we can
    simple call from anywhere

    ""

```

Run example:

```bash 
arkitekt dev
```

Open the Arkitekt Webinterface (Dashboard) and reserve this function:

You now can assign to this throught he autogenerated widgets.

## Usage with complex Datastructures

Arkitekt takes care of serialization and documentation of standard python datastructures

- str
- bool
- int
- float
- Enum
- Dict
- List
  
To increase performance and latency it is not  possible to serialize complex python objects like numpy arrays into the messages. These are best transformed into immutable objects on a centrally accessible storage and then only the reference is passed.

Arkitekt does not impose any rules on how you handle this storage (see mikro for ideas), it provides however a simple api.

```python

class ComplexStructure:
    id: str # A reference for this structure on central storage

    async def shrink(self):
        return self.id

    @classmethod
    async def expand(cls, value):
        return cls.load_from_server(value)


```

by providing two functions:

- shrink
- expand
  
You can now use this Structure with simple typehints and arkitekt will automaticall shrink (serialize) and expand (deserialize) the structure on calling.

```python

def complex_call(x: ComplexStrucuture) -> int:
    return x.max()

```





## Terminology

**Node** A concept (documentatio) of a function that is enabled on the platform.

**App**: A provider of functions, that negotiates
access right to data and other Apps through Oauth2

**Template**: An Implementation of a Node by an App. 


**Agent**: An active instance of this App, its the host of actors. Agents connect and disconnect.

**Actor**: A stateless instance of a function that was provisioned

**Provision**: A contract between arkitekt and a Agent for the usage of a specific function. As long as the provision is active the connected agent will be required to provide the resources of the function (think Deployment in Kubernetes)

**Reservation**: A contract between a User and arkitekt that wants to use one or mulitple instances of functions (Actors). The platform tries to autocorrect and failure correct. Calls to the function are always address to the
reservation no the provision (think: Exchange in RabbitMQ)